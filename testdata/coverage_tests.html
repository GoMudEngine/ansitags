
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ansigo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Volte6/ansigo/ansigo.go (73.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ansigo

import (
        "bufio"
        "bytes"
        "errors"
        "io"
        "regexp"
        "strconv"
        "strings"
)

const (
        tagOpenStart  string = "&lt;ansi"
        tagOpenEnd    string = "&gt;"
        tagCloseStart string = "&lt;/ansi"
        tagCloseEnd   string = "&gt;"
        // regex result data indices
        matchPosFull  int = 0
        matchPosTag   int = 1
        matchPosValue int = 2
        // special values to modify 8 bit color codes
        fgToBgIncrement int = 10
        boldIncrement   int = 60

        tagTypeNone  uint8 = 0
        tagTypeOpen  uint8 = 1
        tagTypeClose uint8 = 2
        tagTypeBoth  uint8 = 3

        defaultFg int = 39
        defaultBg int = 49
)

var (
        // errors
        errTagsNotFound error = errors.New("ansi tag not found")
        // regular expressions
        propertyRegex, _ = regexp.Compile(" (bg|fg|bold)=[\"']?([a-z0-9]+)[\"']?")
        // map of strings to 4 bit color codes
        colorMap map[string]int = map[string]int{
                "black":   30,
                "red":     31,
                "green":   32,
                "yellow":  33,
                "blue":    34,
                "magenta": 35,
                "cyan":    36,
                "white":   37,
        }
)

type tagMatch struct {
        startPos int
        endPos   int
}

type ansiProperties struct {
        fg   int
        bg   int
        bold bool
}

func Parse(str string) string <span class="cov4" title="16">{

        input := bufio.NewReader(strings.NewReader(str))

        var outputBuffer bytes.Buffer
        output := bufio.NewWriter(&amp;outputBuffer)
        if err := ParseStreaming(input, output); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov4" title="16">return outputBuffer.String()</span>
}

func ParseStreaming(inbound *bufio.Reader, outbound *bufio.Writer) error <span class="cov4" title="16">{

        var tagStack []*ansiProperties = make([]*ansiProperties, 0, 5)

        var sBuilder strings.Builder
        var currentTagBuilder strings.Builder
        var tagPosition int = 0
        var tagType uint8 = tagTypeNone

        var tagOpenParts []byte = []byte(tagOpenStart)
        var tagCloseParts []byte = []byte(tagCloseStart + tagCloseEnd)
        var tagStartChar byte = tagOpenParts[0]

        for </span><span class="cov10" title="1395">{
                input, err := inbound.ReadByte()
                if err != nil &amp;&amp; err == io.EOF </span><span class="cov4" title="16">{
                        break</span>
                }

                <span class="cov9" title="1379">if sBuilder.Len() &gt;= 128 </span><span class="cov0" title="0">{
                        outbound.WriteString(sBuilder.String())
                        sBuilder.Reset()
                        outbound.Flush()
                }</span>

                <span class="cov9" title="1379">if tagType == tagTypeNone &amp;&amp; tagPosition == 0 &amp;&amp; input != tagStartChar </span><span class="cov8" title="434">{
                        sBuilder.WriteByte(input)
                        continue</span>
                }

                // if NOT in a sequence:
                // 1.) Check whether the input is the next char in a sequence

                // if IN a sequence:
                // 1.) If current tag type is both, try and narrow down which one we are looking at
                // 2.) Check wehther next char is in the sequence for the current tag type
                // 3.) if not, reset everything.
                //fmt.Print(string(input))
                // If not in the middle of a tag, or the tag hasn't been narrowed yet
                <span class="cov9" title="945">if tagType == tagTypeNone || tagType == tagTypeBoth </span><span class="cov6" title="106">{

                        if input == tagOpenParts[tagPosition] </span><span class="cov6" title="81">{

                                if input == tagCloseParts[tagPosition] </span><span class="cov5" title="53">{
                                        tagType = tagTypeBoth
                                }</span> else<span class="cov5" title="28"> {
                                        tagType = tagTypeOpen
                                }</span>

                                <span class="cov6" title="81">currentTagBuilder.WriteByte(input)
                                tagPosition++
                                continue</span>
                        }

                        <span class="cov5" title="25">if input == tagCloseParts[tagPosition] </span><span class="cov5" title="25">{
                                tagType = tagTypeClose
                                currentTagBuilder.WriteByte(input)
                                tagPosition++
                                continue</span>
                        }

                        <span class="cov0" title="0">if tagType != tagTypeNone </span><span class="cov0" title="0">{
                                // We've failed to find a match, reset everything, write what we've got to the output
                                tagType = tagTypeNone
                                currentTagBuilder.WriteByte(input)
                                sBuilder.WriteString(currentTagBuilder.String())
                                currentTagBuilder.Reset()
                                tagPosition = 0
                                continue</span>
                        }

                        <span class="cov0" title="0">sBuilder.WriteByte(input)</span>

                } else<span class="cov9" title="839"> {

                        if tagType == tagTypeOpen </span><span class="cov9" title="714">{

                                // if still trying to reach the end...
                                if tagPosition &lt; len(tagOpenParts) </span><span class="cov6" title="84">{

                                        // if still tracking...
                                        if input == tagOpenParts[tagPosition] </span><span class="cov6" title="84">{
                                                currentTagBuilder.WriteByte(input)
                                                tagPosition++
                                                continue</span>
                                        } else<span class="cov0" title="0"> {

                                                // fell off. Reset it all.
                                                tagType = tagTypeNone
                                                sBuilder.WriteString(currentTagBuilder.String())
                                                currentTagBuilder.Reset()
                                                tagPosition = 0
                                                continue</span>
                                        }

                                } else<span class="cov9" title="630"> {

                                        // If this is the final closing string of the open tag
                                        if string(input) == tagOpenEnd </span><span class="cov5" title="27">{

                                                currentTagBuilder.WriteByte(input)

                                                newTag := extractProperties(currentTagBuilder.String())

                                                stackLen := len(tagStack)

                                                currentTagBuilder.Reset()

                                                if stackLen &gt; 0 </span><span class="cov2" title="4">{
                                                        sBuilder.WriteString(newTag.PropagateAnsiCode(tagStack[stackLen-1]))
                                                }</span> else<span class="cov4" title="23"> {
                                                        sBuilder.WriteString(newTag.PropagateAnsiCode(nil))
                                                }</span>

                                                <span class="cov5" title="27">tagStack = append(tagStack, newTag)

                                                tagType = tagTypeNone
                                                tagPosition = 0

                                                continue</span>

                                        } else<span class="cov8" title="603"> {
                                                currentTagBuilder.WriteByte(input)
                                                continue</span>
                                        }

                                }

                        }

                        <span class="cov7" title="125">if tagType == tagTypeClose </span><span class="cov7" title="125">{

                                // if still trying to reach the end...
                                if tagPosition &lt; len(tagCloseParts)-1 </span><span class="cov6" title="100">{

                                        // if still tracking...
                                        if input == tagCloseParts[tagPosition] </span><span class="cov6" title="100">{
                                                currentTagBuilder.WriteByte(input)
                                                tagPosition++
                                                continue</span>
                                        } else<span class="cov0" title="0"> {
                                                // fell off. Reset it all.
                                                tagType = tagTypeNone
                                                sBuilder.WriteString(currentTagBuilder.String())
                                                currentTagBuilder.Reset()
                                                tagPosition = 0
                                                continue</span>
                                        }

                                } else<span class="cov5" title="25"> {
                                        currentTagBuilder.Reset()

                                        // we're already at the end, we can parse it.
                                        stackLen := len(tagStack)

                                        if stackLen &gt; 2 </span><span class="cov1" title="2">{
                                                sBuilder.WriteString(tagStack[stackLen-2].PropagateAnsiCode(tagStack[stackLen-3]))
                                        }</span> else<span class="cov4" title="23"> if stackLen &gt; 1 </span><span class="cov1" title="2">{
                                                sBuilder.WriteString(tagStack[stackLen-2].PropagateAnsiCode(nil))
                                        }</span> else<span class="cov4" title="21"> {
                                                sBuilder.WriteString(AnsiResetAll())
                                        }</span>

                                        <span class="cov5" title="25">if stackLen &gt; 0 </span><span class="cov4" title="24">{
                                                tagStack[len(tagStack)-1] = nil
                                                tagStack = tagStack[0 : len(tagStack)-1]
                                        }</span>

                                        <span class="cov5" title="25">tagType = tagTypeNone
                                        tagPosition = 0

                                        continue</span>
                                }

                        }

                }

        }

        <span class="cov4" title="16">if currentTagBuilder.Len() &gt; 0 </span><span class="cov1" title="1">{
                sBuilder.WriteString(currentTagBuilder.String())
                currentTagBuilder.Reset()
        }</span>

        // if there were any unclosed tags in the stream
        <span class="cov4" title="16">if len(tagStack) &gt; 0 </span><span class="cov2" title="3">{
                sBuilder.WriteString(AnsiResetAll())
        }</span>

        <span class="cov4" title="16">if sBuilder.Len() &gt; 0 </span><span class="cov4" title="16">{

                outbound.WriteString(sBuilder.String())

        }</span>

        <span class="cov4" title="16">outbound.Flush()
        return nil</span>
}

func (p *ansiProperties) AnsiReset() string <span class="cov0" title="0">{
        return "\033[39;49m"
}</span>

func (p ansiProperties) AnsiCode() string <span class="cov0" title="0">{

        if p.bold </span><span class="cov0" title="0">{
                if p.fg &lt; 90 &amp;&amp; p.fg != defaultFg </span><span class="cov0" title="0">{
                        p.fg += boldIncrement
                }</span>
                <span class="cov0" title="0">if p.bg &lt; 90 &amp;&amp; p.fg != defaultBg </span><span class="cov0" title="0">{
                        p.bg += boldIncrement
                }</span>
        }

        <span class="cov0" title="0">return "\033[" + strconv.Itoa(p.fg) + ";" + strconv.Itoa(p.bg) + "m"</span>

}

func (p ansiProperties) PropagateAnsiCode(previous *ansiProperties) string <span class="cov5" title="31">{

        if previous != nil </span><span class="cov3" title="6">{
                if p.fg == defaultFg </span><span class="cov0" title="0">{
                        p.fg = previous.fg
                }</span>
                <span class="cov3" title="6">if p.bg == defaultBg </span><span class="cov0" title="0">{
                        p.bg = previous.bg
                }</span>
                <span class="cov3" title="6">if !p.bold </span><span class="cov3" title="5">{
                        p.bold = previous.bold
                }</span>
        }

        <span class="cov5" title="31">if p.bold </span><span class="cov2" title="3">{
                if p.fg &lt; 90 &amp;&amp; p.fg != defaultFg </span><span class="cov2" title="3">{
                        p.fg += boldIncrement
                }</span>
                <span class="cov2" title="3">if p.bg &lt; 90 &amp;&amp; p.fg != defaultBg </span><span class="cov2" title="3">{
                        p.bg += boldIncrement
                }</span>
        }

        <span class="cov5" title="31">return "\033[" + strconv.Itoa(p.fg) + ";" + strconv.Itoa(p.bg) + "m"</span>

}

func AnsiResetAll() string <span class="cov4" title="24">{
        return "\033[0m"
}</span>

func extractProperties(tagStr string) *ansiProperties <span class="cov5" title="27">{
        ret := &amp;ansiProperties{fg: defaultFg, bg: defaultBg}

        result := propertyRegex.FindAllStringSubmatch(tagStr, -1)
        var err error
        for _, val := range result </span><span class="cov5" title="48">{

                switch val[matchPosTag] </span>{
                case "fg":<span class="cov4" title="24">
                        if ret.fg, err = strconv.Atoi(val[matchPosValue]); err != nil </span><span class="cov4" title="24">{
                                // if couldn't find a number, check for a mapped string
                                if val, ok := colorMap[val[matchPosValue]]; ok </span><span class="cov4" title="23">{
                                        ret.fg = val
                                }</span> else<span class="cov1" title="1"> {
                                        ret.fg = defaultFg //-1
                                }</span>
                        }
                case "bg":<span class="cov4" title="20">
                        if ret.bg, err = strconv.Atoi(val[matchPosValue]); err != nil </span><span class="cov4" title="19">{
                                // if couldn't find a number, check for a mapped string
                                if val, ok := colorMap[val[matchPosValue]]; ok </span><span class="cov4" title="18">{
                                        // increment value to make it a bg value
                                        ret.bg = val + fgToBgIncrement
                                }</span> else<span class="cov1" title="1"> {
                                        ret.bg = defaultBg //-1
                                }</span>
                        }
                case "bold":<span class="cov2" title="4">
                        if ret.bold, err = strconv.ParseBool(val[matchPosValue]); err != nil </span><span class="cov1" title="1">{
                                ret.bold = false
                        }</span>
                }
                //fmt.Printf("%#v = %#v\n", val[matchPosTag], val[matchPosValue])

        }

        <span class="cov5" title="27">return ret</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
